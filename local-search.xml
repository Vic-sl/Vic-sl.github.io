<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习笔记-(FreeRTOS)</title>
    <link href="/2022/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-FreeRTOS/"/>
    <url>/2022/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-FreeRTOS/</url>
    
    <content type="html"><![CDATA[<h1>学习笔记（基于ESP32的FreeRTOS）</h1><p>基于ESP32的FreeRTOS，参考ESP32官方的ESP-IDF开发，目的为使用FreeRTOS管理任务，实现FOC算法控制，本文为学习FreeRTOS所记录笔记。</p><span id="more"></span><h2 id="Day1-2022-12-05">Day1 (2022-12-05)</h2><h3 id="Task-API-任务">Task API(任务)</h3><ol><li class="lvl-3"><h4 id="任务的创建">任务的创建</h4><p>  在app_main()中使用<code>xTaskCreate(任务函数名字, 任务名字, 堆栈的大小, 传入参数, 任务优先级, 任务句柄)</code>创建任务。其中任务句柄为<code>TaskHandle_t</code>类型。</p></li><li class="lvl-3"><h4 id="任务的结束">任务的结束</h4><p>  在任务函数中使用<code>vTaskDelete(NULL)</code>结束任务，在app_main()中使用<code>vTakeDelete(任务句柄)</code>结束任务。</p></li><li class="lvl-3"><h4 id="任务优先级">任务优先级</h4><ol><li class="lvl-6">同一优先级的任务按照先创建先运行的原则进行，不同优先级则为优先级大先运行，esp-idf默认最大优先级为24，可在<code>esp-idf\components\freertos\esp_additions\include\freertos\FreeRTOSConfig.h</code>文件中修改<code>configMAX_PRIORITIES</code>的设定值改变其最大优先级。</li><li class="lvl-6">获取任务优先级，使用<code>uxTaskPriorityGet(任务句柄)</code>获得任务优先级，定义一个<code>UBaseType_t</code>类型变量来存储任务的优先级，其本质是<code>unsigned int</code>类型。</li><li class="lvl-6">修改任务优先级，使用<code>vTaskPrioritySet(任务句柄, 修改的任务优先级)</code>修改任务优先级。</li></ol></li><li class="lvl-3"><h4 id="任务的挂起（暂停）">任务的挂起（暂停）</h4><p>  使用<code>vTaskSuspend(NULL)</code>在任务函数中挂起自己，使用<code>vTaskSuspend(任务句柄)</code>挂起指定任务。</p></li><li class="lvl-3"><h4 id="任务的恢复">任务的恢复</h4><ol><li class="lvl-6">使用<code>vTaskResume(任务句柄)</code>恢复任务，使任务继续执行。</li><li class="lvl-6">在任务函数中使用<code>vTaskSuspendAll()</code>会使CPU只执行任务函数中的后续代码，其他任务将会被挂起，在使用<code>vTaskResumeAll()</code>后，其他任务才能继续执行。但是，在使用<code>vTaskSuspendAll()</code>时中断仍处于启用状态。</li></ol></li><li class="lvl-3"><h4 id="获取任务信息">获取任务信息</h4><p>  使用<code>vTaskList()</code>打印系统任务信息，包括任务名字、运行状态、任务优先级、使用堆栈大小、任务编号。需定义一个<code>static char</code>类型变量存储任务信息。但在单片机寸金寸土的内存里面，使用<code>vTaskLinst()</code>会占用很大的内存，一般不使用这个函数获取任务信息。</p><p>  取而代之在FreeRTOS中常用查看任务所用栈的函数为<code>uTaskGetStackHighWaterMark()</code>，用于获取任务剩余栈的程度。在FreeRTOS中每个任务维护自己的堆栈，总堆栈大小在创建任务时指定。该函数所返回类型为<code>UBaseType_t</code>。</p></li></ol><h2 id="Day2-2022-12-07">Day2 (2022-12-07)</h2><h3 id="Task-API-任务-2">Task API(任务)</h3><ol><li class="lvl-3"><h4 id="Watchdogs-看门狗">Watchdogs(看门狗)</h4><p>  ESP-IDF支持两种看门狗计时器，中断看门狗计时器(Interrupt Watchdog Timer (IWDT))与任务看门狗计时器(Task Watchdog Timer (TWDT))，中断看门狗在后面学习中断时使用。</p><p>  任务看门狗的使用</p><ul class="lvl-2"><li class="lvl-5"><p><code>esp_task_wdt_init()</code>初始化TWDT并且订阅<code>idle</code>任务。</p></li><li class="lvl-5"><p><code>esp_task_wdt_add(TaskHandle_t task_handle)</code>给任务添加看门狗。</p></li><li class="lvl-5"><p><code>esp_task_wdt_reset()</code>‘喂狗’，在给任务添加看门狗后一段时间要调用该函数’feed TWDT’，否则看门狗会报错，‘一段时间’在ESP-IDF的配置文件中设置。</p></li><li class="lvl-5"><p><code>esp_task_wdt_delete(TaskHandle_t task_handle)</code>删除任务的看门狗。</p></li></ul></li></ol><h2 id="Day3-2022-12-08">Day3 (2022-12-08)</h2><h3 id="Queue-API-队列">Queue API(队列)</h3><ol><li class="lvl-3"><h4 id="队列的创建">队列的创建</h4><p>  使用<code>xQueueCreate(UBaseype_t uxQueueLength, UBaseType_t uxItemSize)</code>创建一个新队列返回一个队列句柄，可通过调用该句柄可引用该队列。<code>uxQueueLength</code>为队列最大容纳项目数，<code>uxItemSize</code>为存储在队列中每个数据项的大小，单位为字节(bytes)。</p><p>  其返回值若为<code>NULL</code>则创建队列失败，因为没有足够的堆内存分配队列数据结构和存储区域，若成功创建队列返回值则为队列的句柄，可通过它引用创建的队列。</p><p>  队列用来在任务与任务、任务与中断中传输数据，可以在调度程序开始前或开始后创建。</p><p>将创建好的队列句柄作为<code>Task</code>(任务)的传入参数。</p></li><li class="lvl-3"><h4 id="数据的发送">数据的发送</h4><p>  使用<code>xQueueSend(QueueHandle xQueue, const void * pvItemToQueue, TickType_t xTicksToWait)</code>发送数据到队列中，<code>xQueue</code>为队列句柄，<code>pvItemToQueue</code>为指向传输数据的指针，数据会被复制到队列存储中，<code>xTicksToWait</code>为等待超时时间。</p><p>  其返回值若为<code>pdPASS</code>则发送数据成功，若返回<code>errQUEUE_FULL</code>则发送失败。</p></li><li class="lvl-3"><h4 id="数据的接收">数据的接收</h4><p>  使用<code>xQueueReceive(QueueHandle xQueue, void *pvBuffer, TickType_t xTicksToWait)</code>接收队列的数据，<code>xQueue</code>为队列句柄，<code>pvBuffer</code>为指向接收数据将复制到其中的存储器的指针，<code>xTicksTowait</code>为等待超时时间。</p><p>  其返回值为<code>pdPASS</code>则接收数据成功，若返回<code>errQUEUE_EMPTY</code>则接收数据失败。</p></li></ol><h3 id="Note">Note</h3><p>  在写发送接收数据代码时用到了<code>malloc()</code>与<code>free()</code>申请和释放内存，在发送数据时，需要申请内存进行写入数据操作，申请内存<code>malloc</code>与<code>free()</code>需要同时出现，避免内存溢出，在发送数据中申请内存是在循环内部进行的，每次发送数据后，在接收数据成功时释放内存，所以需要在发送数据的循环内部进行申请内存，而释放内存则在接收数据成功后释放。关于使用<code>malloc</code>与<code>free</code>在另一篇考研C语言篇（待写）文章中。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习路线指南</title>
    <link href="/2022/11/15/Python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2022/11/15/Python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="Python学习路线指南">Python学习路线指南</h2><p>  从进入高中以来便开始接触编程世界，先后学习了C语言、Python以及正在学的C++与rust，由于自学没有规划学习路线，走过不少弯路，现编写此文分享经验。本文只代表个人经验之谈，请结合自我实际情况合理规划路线。</p><span id="more"></span><p>本文思维导图</p><p><img src="/img/mdimg/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png" alt=""></p><p>Python学习内容</p><p><img src="/img/mdimg/python%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9.png" alt=""></p><h3 id="Python基础学习">Python基础学习</h3><p>  Python被誉为最易入门编程语言之一，其语法也是比较简单易学的，对于学习Python我的建议是选择一本经典书籍快速学习，基础入门不需要深入理解，只需学会使用，在学习基础语法时一定要在自己电脑上编写程序，一开始编写不需要注重代码行数与复杂度，后续第三部分会补充该问题。</p><p>  对于学习所选经典书籍推荐<a href="https://www.code-nav.cn/rd/?rid=cbddf0af6064484f002658102cdbba17">《Python编程：从入门到实践》</a>，这里提供电子版，但建议购买一本实体书籍方便学习，也可以作为后续使用充当字典查询使用。还有一些其他书籍资源，笔者将其放在第四部分。</p><p>  Python基础包括变量、运算符和表达式、流程控制、基础数据结构、函数、面向对象编程、模块、包、异常处理以及文件操作，其中面向对象编程是Python的核心之一，模块化编程与包方便以后大型项目管理，文件操作可以在实际生活中更方便以及更快的解决问题，成为同学眼中的会魔法的人。</p><h3 id="Python进阶学习">Python进阶学习</h3><p>  对于Python进阶内容，是对函数进行进阶学习，以及学习正则表达式和并发编程，其中，函数进阶包括</p><blockquote><p>闭包</p></blockquote><blockquote><p>匿名函数</p></blockquote><blockquote><p>生成器</p></blockquote><blockquote><p>函数装饰器</p></blockquote><blockquote><p>高阶函数</p></blockquote><p>  进一步学习函数会使你的代码更加简洁与规范，摆脱编写稚嫩的代码风格。</p><p>“这个问题怎么解决？”</p><p>“我知道，用正则表达式可以解决。”</p><p>那么你现在有两个问题需要解决了。</p><p>  上述是正则表达式里面一句比较经典的对话，表达了正则表达式的学习难度，正则表达式由于其规则较多且为复杂，要熟练使用只能在编程过程中经常使用查阅，通常的Python书籍都会有一章内容包含正则表达式， 其中会有正则表达的规则表，经常使用即可。</p><p>  并发编程是使用编程充分调用计算机硬件以及计算机网络的高级编程方法，并发编程顾名思义，并行着发生的编程方法，基础编程程序通常只能自上至下的单线程运行，并发编程则可以在需要的时候让不互相影响的两项或多项任务同时发生，也可以将一项较大的任务分为几部分小任务并发运行，通过增加计算机使用资源节约完成任务时间。并发编程能够高效完成任务但也带来了相对应的困难，比如并发编程如何控制各个并行任务的运行时间，如何合理的将大任务分割为能运行的小任务，这只能在实际编程中积累编程经验，没有捷径可走。</p><h3 id="编程进阶必备知识">编程进阶必备知识</h3><p>  当掌握Python基础以及进阶使用后，你可能开始接触到使用编程解决现实问题，比如蓝桥杯比赛以及ACM编程大赛等，这里举蓝桥杯的例子是因为这是笔者进入大学在大一参加的第一个比赛，它开启了笔者的大学比赛经历，在参加蓝桥杯比赛只取得省二后便暴露出笔者野路子出家的缺陷，不懂数据结构，不会使用算法，仅凭单单的简单编程经验不能在比赛中走得更远。</p><p>  想要编程能力更近一步，就要理解一个公式<code>程序 = 数据结构 + 算法</code>，它代表了好代码的结构，将实际问题中的数据转换为编程语言中的对应的数据结构，处理这些数据就是使用合适的算法，两者结合解决实际问题才符合科学的编程。</p><p>  学习数据结构推荐浙大陈越老师的数据结构课程，比较经典但是需要集中精力理解所讲内容，在mooc上可以找到本课程。书籍推荐《大话数据结构》。</p><p>  学习算法建议先将《图解算法》学习后，购买《算法导论》学习，前者漫画风格能够很好的培养学习枯燥的算法的兴趣，后者作为计算机经典书籍之一，称为”算法圣经“。在啃这两本书籍时要多写代码，算法要理解并知道其作用与运行结果，空想需要很强大的想象能力。</p><p>  当你成为一个掌握算法与程序结构的大牛后，学习其他编程语言也非常容易，你已经具备属于自己的编程思想，学习其他语言相当于学习它的语法与核心内容，相信你也有了自己的理解。</p><p>  编写代码对个人来说或许容易，但大型项目往往由团队共同完成，因此，编写易读的代码也成为了一种能力，笔者在此推荐<a href="https://google.github.io/styleguide/pyguide.html">谷歌的Python代码规范</a>，在开始学习编程时就要养成编写易读的代码，谷歌作为龙头企业，其代码规范值得学习。</p><p>于此，你已经看到本文的结尾，Python学习也快靠一段落，欢迎大家与笔者交流学习，作为个人，经验会有不足之处，在学习编程的同时也学习了三维建模软件的使用、单片机以及现代文学，期待和大家进行知识火花的碰撞。</p><p>下面是笔者的收集的部分资源，将其做成导图方便大家查看。</p><h3 id="资源">资源</h3><p>Python常用类库</p><p><img src="/img/mdimg/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93.png" alt=""></p><p>资源</p><p><img src="/img/mdimg/%E8%B5%84%E6%BA%90.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十七届智能车视觉组问题收录</title>
    <link href="/2022/11/13/%E5%8D%81%E4%B8%83%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6%E8%A7%86%E8%A7%89%E7%BB%84%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/"/>
    <url>/2022/11/13/%E5%8D%81%E4%B8%83%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6%E8%A7%86%E8%A7%89%E7%BB%84%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="十七届智能车视觉组问题收录">十七届智能车视觉组问题收录</h3><p>第一次参加智能车比赛，在做部分机器视觉与结构建模方面的工作时，遇到了许多问题，编写此篇文章记录。</p><span id="more"></span><ol><li class="lvl-3"><p>问题一</p><p>在按照基础教程配置过程中，遇到了一系列问题，主要是CUDA显卡驱动方面问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">问题： keras-nightly 导入包报错 cannot <span class="hljs-keyword">import</span> name <span class="hljs-string">&#x27;Adam&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;keras.optimizers&#x27;</span><br></code></pre></td></tr></table></figure><p>报错信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.optimizers <span class="hljs-keyword">import</span> Adam<br>ImportError: cannot <span class="hljs-keyword">import</span> name <span class="hljs-string">&#x27;Adam&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;keras.optimozers&#x27;</span><br></code></pre></td></tr></table></figure><p>解决方案</p><p>将错误使用代码修改：</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">错误代码：<br><span class="hljs-keyword">from</span> keras.optimizers <span class="hljs-keyword">import</span> Adam<br>opt = Adam(lr=lr, decay=lr/epochs)<br>修改为：<br><span class="hljs-keyword">from</span> keras.optimizers <span class="hljs-keyword">import</span> adam_v2<br>opt = adam_v2.Adam(lr=lr, decay=lr/epochs)<br></code></pre></td></tr></table></figure></li><li class="lvl-3"><p>问题二：待更新</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>智能车</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能车比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10版本转换激活</title>
    <link href="/2021/08/22/win10%E7%89%88%E6%9C%AC%E8%BD%AC%E6%8D%A2%E6%BF%80%E6%B4%BB/"/>
    <url>/2021/08/22/win10%E7%89%88%E6%9C%AC%E8%BD%AC%E6%8D%A2%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h1>笔记本win10版本转换以及激活</h1><p>本篇文章介绍笔记本win10版本转换以及激活方法</p><span id="more"></span><h3 id="工具准备">工具准备</h3><ul class="lvl-0"><li class="lvl-2"><p>win10版本转换工具</p><p><img src="/img/mdimg/%E7%89%88%E6%9C%AC%E8%BD%AC%E6%8D%A2.png" alt=""></p></li><li class="lvl-2"><p>win10激活工具</p><p><img src="/img/mdimg/%E6%BF%80%E6%B4%BB.png" alt=""></p></li></ul><p>资源待更新，解压压缩包后得到两个文件夹，其中版本一键转换文件夹里面就是版本转换工具，另一文件夹则是激活工具。</p><h3 id="工具准备好后就可以开始进行版本转换了">工具准备好后就可以开始进行版本转换了</h3><p>本文基于联想拯救者R7000P 2020 win10家庭中文版进行演示</p><ul class="lvl-0"><li class="lvl-2"><p>打开版本一键转换软件</p><p><img src="/img/mdimg/%E7%89%88%E6%9C%AC%E8%BD%AC%E6%8D%A2.png" alt=""></p></li><li class="lvl-2"><p>如图所示，点击可以选择转换的版本，下面选项默认即可，点击开始转换，等待转换成功即可</p></li><li class="lvl-2"><p>等待提示版本转换成功后，进入另一文件夹，再进入All-In-One-Version文件夹，右键点击 MAS_1.4_AIO_CRC32_9A7B5B05.cmd 文件，选择以管理员身份运行</p></li><li class="lvl-2"><p><img src="/img/mdimg/%E6%BF%80%E6%B4%BB.png" alt=""></p></li><li class="lvl-2"><p>运行结果如图所示，键盘输入 2 来激活win10版本，其中[2],[3],[4]是三种激活方法，默认选择方法[2]即可，输入2后等待程序运行，当出现[successful]时代表激活成功，恭喜你，win10版本转换激活成功。</p></li></ul><p>进入设置里面可任意查看版本已经转换成功，本教程结束</p>]]></content>
    
    
    <categories>
      
      <category>win10</category>
      
    </categories>
    
    
    <tags>
      
      <tag>win10</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
